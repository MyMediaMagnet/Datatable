= Chumper/Datatable
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectlinks:

image:https://travis-ci.org/Chumper/Datatable.svg?branch=datatable3["Build Status", link="https://travis-ci.org/Chumper/Datatable"]
image:https://poser.pugx.org/chumper/datatable/v/stable["Version", link="https://packagist.org/packages/chumper/datatable"]
image:https://poser.pugx.org/chumper/datatable/downloads["Downloads", link="https://travis-ci.org/Chumper/Datatable"]
image:https://poser.pugx.org/chumper/datatable/v/unstable["Latest Unstable Version", link="https://packagist.org/packages/chumper/datatable"]
image:https://poser.pugx.org/chumper/datatable/license["License", link="https://packagist.org/packages/chumper/datatable"]

== Introduction

This is the development and proposal version of Datatable3 for laravel 5. Here we develop and discuss the structure of
the new version.

== Thanks

NOTE: First all i want to thank Tim Groeneveld for doing such an awesome job on maintaining this library and making it
ready for laravel 5.
Tim, without your help this library would not be what it is now and that you took over the development means a lot to
me, you did a great job and you deserve all my gratitude. Let us improve this library together.

== Usage

Here i want to discuss the proposed usage of the API. In general i would prefer to concentrate on a single route
functionality so we can transfer all server side settings into the view without declaring it twice.

Nevertheless I would also offer the possibility for two routes, which will require more configuration from the developer

=== Single Usage

==== Most basic example

[source, php]
----
$datatable = Datatable::make(new EloquentModelProvider(User::class))

return view("template", $datatable)
----

And in the view

[source, php]
----
{{
    $datatable->table();
    $datatable->script();
    // or
    $datatable->html();

}}
----

So all configurations from the server side are passed to the client side without the need to declare it twice.

=== Client side

[source, php]
----
{{
    $table = Datatable::view()
    ->column("Name", "Email")
    ->url(URL::to('auth/users/table'))
}}

{{
    $table->body() //<1>
    $table->script() //<2>
}}

{{
    $table = Datatable::view()
    ->column("Name", "Email")
    ->url(URL::to('auth/users/table'))
    ->option(...)
    ->html()
}}
----
<1> Render the html table
<2> Render the javascript

Maybe we need to drop the client side of the plugin if it is too much work, but i always liked the easy setup with the
tables.

=== Server side

[source, php]
----

Datatable::data($provider)
    ->...

----

I could imagine different providers, like `CollectionProvider` , `EloquentProvider` or even your own providers.

This would decouple the provider configuration from the engine and makes it easier to add new providers.

==== ColumnConfiguration

The `Datatable` should only contain the configuration of the data, while the `Provider` do all the heavy lifting with
the data.

I can imagine the column configuration be look something like this:

[source, php]
----

Datatable::data($provider)
    ->column('name') // just show the name column of the data without any additional configuration
    ->column('name', 'Username') // show the name column and map the view header cell to the name `Username`
    ->column('name', function($data) { return $data->username; }) // return custom data within a function
    ->column('name', 'Username', function($data) { return $data->username; }) // name, mapping and function
    ->configure('name', function($data) { return $data->username; }) // will return a ColumnConfigurer
        ->searchable(...)
        ->orderable(...)
        ->regex(...)
        ->label(...)
        ->build()

----

The `Datatable` then holds a configuration of all columns and accepts the incoming request parameters.
It will then delegate the data processing to the `Provider` and will provide a `ColumnConfiguration` object and
a `PresenterDetail` or similar which will include information on what the frontend requested.

=== Internal usage

Internally i would like to change the structure to be more flexible.
E.g. we should only hve one method that will accept the data `Datatable::data($provider)`
where the `$provider` will provide all the extra operations on the object.

I would also like to make the api more fluent.

The `data(...)` method will return a builder where all other base methods can be called upon:
[source]
----
->visible("name")
->searchable("name")
->column('foo', function($data) { return $data->bar; })
----

=== To discuss

Where should the declarations of searchable and orderable columns happen?::
Normally it is part of the jquery declaration, but maybe it is easier to define it on the backend and transfer it to
the frontend.

Can we glue together the `data(...)` and `html(...)` method?::
In my opinion it would be the best to declare the datable ones and get the same behaviour in the frontend and the
backend, but i currently have no idea on how to achieve this.

Can we include some adapters into the library?::
I would love to include some common adapters into the library, like DatePicker, SingleColumnSearch or even an Editor with live update.
I can imagine that it would look like this

[source, php]
----
Datatable::data(...)
    ->adapter(new SingleColumnSearchAdapter(...))
    ->adapter(
        new EditorAdapter(
            ...model to edit,
            ...url to POST to
            ...fields to edit,
            ...template,
            ...etc
        )
    )
----

Maybe we need to customize the javascript for that so we need to pacakge that with the plugin
