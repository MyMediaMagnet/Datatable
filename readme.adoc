= Chumper/Datatable
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectlinks:

image:https://travis-ci.org/OpenSkill/Datatable.svg?branch=master["Build Status", link="https://travis-ci.org/OpenSkill/Datatable"]
image:https://coveralls.io/repos/OpenSkill/Datatable/badge.svg?branch=master&service=github[Coverage Status, link="https://coveralls.io/github/OpenSkill/Datatable?branch=master"]
image:https://poser.pugx.org/openskill/datatable/license[License, link="https://packagist.org/packages/openskill/datatable"]
image:https://poser.pugx.org/openskill/datatable/version[Latest Stable Version, link="https://packagist.org/packages/openskill/datatable"]
image:https://poser.pugx.org/openskill/datatable/v/unstable[Latest Unstable Version, link="https://packagist.org/packages/openskill/datatable"]

== Introduction

This is the development repository for the refactor of Chumper/Datatable for Laravel 5.
In this repository we are developing and discussing the structure of the new version.

== Todo List

See https://github.com/OpenSkill/Datatable/issues/2[issue #2 in the bug tracker] for an up to date 
list of current issues.

== Usage

Here i want to discuss the proposed usage of the API. In general i would prefer to concentrate on a single route
functionality so we can transfer all server side settings into the view without declaring it twice.

Nevertheless I would also offer the possibility for two routes, which will require more configuration from the developer

=== Single Usage

==== Most basic example

[source, php]
----
$datatable = Datatable::make(new EloquentModelProvider(User::class))
    ->column('name')
    ->build

return view("template", $datatable)
----

And in the view

[source, php]
----
{{
    $datatable->table();
    $datatable->script();
    // or
    $datatable->html();

}}
----

So all configurations from the server side are passed to the client side without the need to declare it twice.

=== Client side

[source, php]
----
{{
    $table = Datatable::view()
    ->column("Name", "Email")
    ->url(URL::to('auth/users/table'))
}}

{{
    $table->body() //<1>
    $table->script() //<2>
}}

{{
    $table = Datatable::view()
    ->column("Name", "Email")
    ->url(URL::to('auth/users/table'))
    ->option(...)
    ->html()
}}
----
<1> Render the html table
<2> Render the javascript

Maybe we need to drop the client side of the plugin if it is too much work, but i always liked the easy setup with the
tables.

=== Server side

[source, php]
----

Datatable::make($provider)
    ->...

----

I could imagine different providers, like `CollectionProvider` , `EloquentProvider` or even your own providers.

This would decouple the provider configuration from the engine and makes it easier to add new providers.

==== ColumnConfiguration

The `Datatable` should only contain the configuration of the data, while the `Provider` do all the heavy lifting with
the data.

I can imagine the column configuration be look something like this:

[source, php]
----

Datatable::data($provider)
    ->column('name') // just show the name column of the data without any additional configuration
    ->column('name', 'Username') // show the name column and map the view header cell to the name `Username`
    ->column('name', function($data) { return $data->username; }) // return custom data within a function
    ->column('name', 'Username', function($data) { return $data->username; }) // name, mapping and function
    ...
----

The `Datatable` then holds a configuration of all columns and accepts the incoming request parameters.
It will then delegate the data processing to the `Provider` and will provide a `ColumnConfiguration` object and
a `PresenterDetail` or similar which will include information on what the frontend requested.

=== Internal usage

Internally i would like to change the structure to be more flexible.
E.g. we should only hve one method that will accept the data `Datatable::data($provider)`
where the `$provider` will provide all the extra operations on the object.

I would also like to make the api more fluent.

The `data(...)` method will return a composer where all other base methods can be called upon:
[source]
----
->column('foo', function($data) { return $data->bar; })
----

=== To discuss

Where should the declarations of searchable and orderable columns happen?::
Normally it is part of the jquery declaration, but maybe it is easier to define it on the backend and transfer it to
the frontend.

Can we glue together the `data(...)` and `html(...)` method?::
In my opinion it would be the best to declare the datable ones and get the same behaviour in the frontend and the
backend, but i currently have no idea on how to achieve this.

Can we include some adapters into the library?::
I would love to include some common adapters into the library, like DatePicker, SingleColumnSearch or even an Editor with live update.
I can imagine that it would look like this

[source, php]
----
Datatable::data(...)
    ->adapter(new SingleColumnSearchAdapter(...))
    ->adapter(
        new EditorAdapter(
            ...model to edit,
            ...url to POST to
            ...fields to edit,
            ...template,
            ...etc
        )
    )
----

Maybe we need to customize the javascript for that so we need to pacakge that with the plugin
